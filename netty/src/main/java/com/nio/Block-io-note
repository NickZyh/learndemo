什么是IO：
将数据读取到程序的内存中,或者将程序的数据写出到其他地方.核心对象是程序的工作内存.

输出方向：
Input和Output是有参照物的,参照物就是程序工作内存.写出称为输出流,读入称为输入流.

IO流：
流的底层都是字节流,字符流是对字节流的一个包装,能够更方便的处理.

顶级父类：
字节流 InputStream/OutputSteam
字符流 Reader/Writer

使用流的逻辑
1 读取流
    open a stream -> while more information -> read -> close stream
2 写出流
    open a stream -> while more information -> write -> close stream

普通IO的方向是单一的,一个流只有可能是Input或Output中的一个,这和NIO是截然不同的.

流的分类
节点流：从特定地方读写的流,例如一块磁盘或者一块内存区域
过滤流：过滤流是使用一个已经存在的节点流来创建的.
节点流直接跟设备打交道,而过滤流则是对节点流的一种处理.
过滤流一定是基于节点流来进行构建;节点流一定是和设备来构建的,比如说指定一个url来进行流的读写.

IO流执行的chain
1 读取流
数据源 -> inputStream节点流 -> 过滤流链 -> 数据
2 写出流
数据 -> 过滤流链 -> outputSteam节点流 -> 数据源
例如
AAA,BBB,CCC,其中AAA是节点流,BBB和CCC是过滤流
new CCC(new BBB(new AAA()))
这也是IO库的一个设计原则,通过装饰者模式来动态的组合不同的基本功能,从而实现强大的IO机制。

装饰者模式：装饰者模式是对对象功能的一种扩展,通过不断包装一个对象,从而动态的组合对象的功能.
new A() 只具有A的功能
new B(new A()) 具有A和B的功能
new C(new B(new A())) 具有A,B,C的功能
装饰者的四个角色
1 抽象构建角色：被包装的对象的抽象
2 具体构建角色：被包装的对象的具体实现
3 装饰角色：提供具体构建角色信息给具体装饰角色
4 具体装饰角色：负责给构建对象“包装”功能的具体实现
使用场景：
1 不影响被装饰对象的情况下,动态的添加对象的新功能
2 给对象增加的职责在未来可能会发生改变和扩展

装饰者模式在IO体系中的应用
整个Java的IO体系是基于装饰者模式来设计的
举例：
FilterInputStream:过滤流的顶层父类,继承于InputStream,用于向过滤流的具体实现提供
InputStream的功能,这些功能都能够被装饰.
过滤流的具体实现：不直接与InputStream的打交道,这主要也是考虑解耦.
InputStream:被装饰对象的顶层父类.
InpuStream的具体实现：能够被包装的具体实现.